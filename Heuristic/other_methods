    @staticmethod
    def get_student_intervals(lecture_intervals, all_intervals):
        """
        determines the intervals of student participation
        Args:
            lecture_intervals (np.ndarray): the intervals for lecture
            all_intervals (np.ndarray): the intervals for all talking in lecture
        Returns:
            np.ndarray: the intervals for student participation in lecture
        """

        label_list = []

        for chunk in all_intervals:  # 35 dbs
            lectures_found = 0
            for i in range(0, len(lecture_intervals)):  # 20 dbs

                lecture = lecture_intervals[i]

                if chunk[1] > lecture[1] >= chunk[0]:

                    if lectures_found == 0 and lecture[0] > chunk[0]:
                        label_list.append(np.array([chunk[0], lecture[0]]))
                        lectures_found +=1

                    lectures_found += 1
                    start = lecture[1]
                    lecture_end = lecture_intervals[i+1][0]
                    chunk_end = chunk[1]
                    if chunk_end < lecture_end:
                        label_list.append(np.array([start, chunk_end]))
                    else:
                        label_list.append(np.array([start, lecture_end]))
                elif lecture[1] == lecture_intervals[len(lecture_intervals) - 1][1] and chunk[1] == lecture[1]:
                    start = lecture_intervals[len(lecture_intervals) - 2][1]
                    end = lecture[0]
                    if chunk[0] > end:
                        label_list.append(np.array([start, chunk[0]]))
                    else:
                        label_list.append(np.array([start, end]))
                    lectures_found += 1

            if lectures_found == 0:
                label_list.append(chunk)

        return np.array(label_list)
        
    @staticmethod
    def combine_interval_sets(lecture_intervals, student_intervals):
        label_list = []
        
        i = 0
        j = 0
        lecture_chunk_comes_first = True
        lecture_intervals_finished = False
        student_intervals_finished = False

        if student_intervals.size == 0:
            student_intervals_finished = True
        
        if lecture_intervals.size == 0:
            lecture_intervals_finished = True

        while not lecture_intervals_finished or not student_intervals_finished:
            if lecture_intervals_finished:
                lecture_chunk = [math.inf, math.inf]
            else:
                lecture_chunk = lecture_intervals[i]

            if student_intervals_finished:
                student_chunk = [math.inf, math.inf]
            else:
                student_chunk = student_intervals[j]
            
            if lecture_chunk[0] < student_chunk[0]:
                lecture_chunk_comes_first = True
            else:
                lecture_chunk_comes_first = False
            
            if lecture_chunk_comes_first:
                label_list.append(lecture_chunk)
                i += 1
            else:
                label_list.append(student_chunk)
                j += 1

            if (i == len(lecture_intervals)):
                i = -1
                lecture_intervals_finished = True
            elif (j == len(student_intervals)):
                j = -1
                student_intervals_finished = True
                
        return np.array(label_list)
            
